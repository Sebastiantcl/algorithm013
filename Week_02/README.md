学习笔记--HashMap源码解析之二叉树和红黑树

这里的难点是红黑树的操作“增删改查"
定义：红黑树是一种自平衡的二叉查找树，是一种高效的查找树。红黑树有良好的效率，它可以在时间复杂度为O(logN)时间内完成查找 增加 删除等操作。
性质：
1.根是黑色
2.节点是红色或者黑色
3.所有的叶子都是黑色的（叶子是NIL节点）
4. 每个红色节点必须有两个黑色的子节点
5. 从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点

二叉查找树

为了方便查找：实现二叉查找树，定义：当前根节点的左边全部比根节点小，当前根节点的右边全部比根节点大。

计算树的深度,只需求出左节点的树深度 和右节点的树深度  求其最大值

二叉查找树的性质可以得出，从根节点一直往左走，直至无左路可走，即得最小元素；从根节点一直往右走，直至无右路可走，即得最大元素。对于二叉树查找出最大值：找出树左边最大值，找出树右边最大值，比较大小即可获取。

红黑树

       一种二叉查找树，但在每个结点上增加一个存储位表示结点的颜色，可以是Red或Black。 通过对任何一条从根到叶子的路径上各个结点着色方式的限制，红黑树确保没有一条路径会比其他路径长出俩倍，因而是接近平衡的。

       红黑树虽然本质上是一棵二叉查找树，但它在二叉查找树的基础上增加了着色和相关的性质使得红黑树相对平衡，从而保证了红黑树的查找、插入、删除的时间复杂度最坏为O(log n)。

 因为每一个红黑树也是一个特化的二叉查找树，因此红黑树上的只读操作与普通二叉查找树上的只读操作相同。然而，在红黑树上进行插入操作和删除操作会导致不再符合红黑树的性质。恢复红黑树的属性需要少量(O(log n))的颜色变更(实际是非常快速的)和不超过三次树旋转(对于插入操作是两次)。虽然插入和删除很复杂，但操作时间仍可以保持为O(log n) 次。

size为HashMap中K-V的实时数量
loadFactor加载因子，是用来衡量 HashMap 满的程度，计算HashMap的实时加载因子的方法为：size/capacity，而不是占用桶的数量去除以capacity。capacity 是桶的数量，也就是 table 的长度length。
*threshold计算公式：capacity * loadFactor。这个值是当前已占用数组长度的最大值。过这个数目就重新resize(扩容)，扩容后的 HashMap 容量是之前容量的两倍
默认负载因子为0.75（load_factor = 0.75），那么临界值就为threshold = 0.75 * 16 = 12，只要Entry的数量大于12，就会触发扩容操作
负载因子的作用，获得性能与容量的平衡，过高可能会导致读写耗时增加、过低可能会浪费过多内存；

put方法的实现是将key通过哈希运算求得整形的哈希值hash，再通过调用putVal方法实现元素的添加.
1)通过运算（hash & (length - 1)）得到数组下标对应的元素为null，则创建Node并直接赋值即可。注意在这里插入元素在数组中的下标此时是 （hash & (length - 1)）
2)如果需要被添加的元素的key与在该小标中已经存在的元素的key值相等（hash相等、且key值相等），则此时不会添加元素 ，直接对该元素的值进行修改,并将修改前的值返回
3)else if (p instanceof TreeNode)这一句是JDK8以后的一个巨大改动——如果已经存在的元素是TreeNode的实例对象，则表明该数组下标下已经生成了一个红黑树的数据结构，存储了至少8个元素,而数组中的这个TreeNode对象，正好是红黑树的根节点。此时只需要调用TreeNode的putTreeVal方法，按照红黑树的规则添加元素，而这里需要注意的是：

      a. HashMap中主干部分依旧是Node数组，TreeNode是Node的子类；只有红黑树的根节点在Node数组中；

      b. 红黑树是按照整形变量hash来生成的；它们通过比较Node的hash值来判断左右儿子

4)最后来到else，如果不符合前两者情况，只能按照JDK8以前的数据结构——链表进行链接，即，第一个添加在该数组下标内的元素为链首，通过成员变量next记录下一个元素。在JDK8中，向链表中添加元素后，会多一个判断：如果链表长度大于等TREEIFY_THRESHOLD（8），则会执行treeifyBin方法，将链表转换为红黑树。

remove方法，依然是先从first = tab[(n - 1) & hash]，但是length 会变，很可能找不到了。注意，Node<K,V>[] table 的头索引是 (n - 1) & hash，不是0,并且它还是红黑树的root节点
     a.如果hash值相同，且key相同，直接将元素p的next变量赋值给该下标的元素（如果没有下一个元素，则置为null），并将p返回。
     b.如果不同，且p的next变量不为null，意味着该数组下标下的元素已经形成一根链表、或者红黑树（JDK8及以后），需要进行遍历（或查找）。
       如果找到，则会根据相应的数据结构调用不同的方法进行“删除”操作：
            链表会直接将该元素的前一元素中的next变量修改为需要被删除元素的next变量（即从链表结构中删除该元素的引用），并将其返回；
            红黑树的话会调用TreeNode的removeTreeNode方法进行删除；


get方法调用，同上，首先从头元素开始找，
                  如果找不到就判断是否时红黑树，是的话，就调用二叉树方法去找，((TreeNode<K,V>)first).getTreeNodegetNode
                  如果不是，就用链表遍历的方法去查找
